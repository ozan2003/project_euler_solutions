use project_euler::project_euler_solution;
use project_euler::utils::primes::is_prime;

project_euler_solution!(027);

/// The number of consecutive primes generated by the quadratic expression
/// `n^2 + an + b`.
#[allow(clippy::cast_sign_loss)]
fn number_of_consecutive_primes<F: Fn(i32) -> i32>(func: F) -> i32
{
    let mut tally = 0;

    while is_prime(func(tally) as u64)
    {
        tally += 1;
    }

    tally
}

/// # Quadratic Primes
///
/// Euler discovered the remarkable quadratic formula:
///
/// `n^2 + n + 41`
///
/// It turns out that the formula will produce 40 primes for the consecutive
/// values `n = 0` to `39`. However, when `n = 40`, `40^2 + 40 + 41 = 40(40 + 1)
/// + 41` is divisible by `41`, and certainly when `n = 41`, `41^2 + 41 + 41` is
/// clearly divisible by `41`.
///
/// The incredible formula `n^2 - 79n + 1601` was discovered, which produces 80
/// primes for the consecutive values `n = 0` to `79`. The product of the
/// coefficients, `-79` and `1601`, is `-126479`.
///
/// Considering quadratics of the form:
///
/// `n^2 + an + b`, where `|a| < 1000` and `|b| < 1000`
///
/// where `|n|` is the modulus/absolute value of `n` e.g. `|11| = 11` and `|-4|
/// = 4`
///
/// Find the product of the coefficients, `a` and `b`, for the quadratic
/// expression that produces the maximum number of primes for consecutive values
/// of `n`, starting with `n = 0`.
#[allow(clippy::doc_markdown)]
fn project_euler_027() -> i32
{
    let mut max_consecutive_prime_n = 0;
    let mut max_product = 0;

    // b must be prime since when n = 0, the polynomial equals `b`.
    // Therefore -999 <= b <= 1000 becomes 2 <= b <= 1000.
    let potential_b: Vec<i32> = (2..=1000)
        .filter(|&x: &i32| is_prime(x.try_into().unwrap()))
        .collect();

    // a must be odd to ensure we get odd numbers for even n.
    for a in (-999..1000).step_by(2)
    {
        for &b in &potential_b
        {
            let consecutive_primes_n = number_of_consecutive_primes(|n| n * n + a * n + b);
            if consecutive_primes_n > max_consecutive_prime_n
            {
                max_consecutive_prime_n = consecutive_primes_n;
                max_product = a * b;
            }
        }
    }

    max_product
}

#[cfg(test)]
mod tests
{
    use super::*;

    #[test]
    fn test_number_of_consecutive_primes()
    {
        assert_eq!(number_of_consecutive_primes(|n| n * n + n + 41), 40);
        assert_eq!(number_of_consecutive_primes(|n| n * n - 79 * n + 1601), 80);
    }
}
